"""
AWS Ï†úÌíà Ï†ïÎ≥¥ ÏàòÏßëÍ∏∞
AWS Í≥µÏãù APIÏóêÏÑú Ï†úÌíà Ï†ïÎ≥¥Î•º ÏàòÏßëÌï©ÎãàÎã§.
"""

import csv
import json
import requests
from typing import List, Dict, Optional
from dataclasses import dataclass
from pathlib import Path

@dataclass
class ProductInfo:
    """Ï†úÌíà Ï†ïÎ≥¥ Îç∞Ïù¥ÌÑ∞ ÌÅ¥ÎûòÏä§"""
    group: str
    service: str
    service_url: str
    product_name: Optional[str] = None
    product_category: Optional[str] = None
    description: Optional[str] = None

class AWSProductCollector:
    """
    AWS Ï†úÌíà Ï†ïÎ≥¥ ÏàòÏßëÍ∏∞
    
    AWS Í≥µÏãù APIÏóêÏÑú Ï†úÌíà Ï†ïÎ≥¥Î•º ÏàòÏßëÌïòÏó¨ Íµ¨Ï°∞ÌôîÎêú Îç∞Ïù¥ÌÑ∞Î•º ÏÉùÏÑ±Ìï©ÎãàÎã§.
    
    ÏÇ¨Ïö© ÏòàÏãú:
    ```python
    collector = AWSProductCollector()
    products = collector.collect_products()
    collector.save_products(products, "output.csv", "output.json")
    ```
    """
    
    def __init__(self, api_url: Optional[str] = None):
        """
        Ï¥àÍ∏∞Ìôî
        
        Args:
            api_url: AWS Ï†úÌíà API URL (Í∏∞Î≥∏Í∞í ÏÇ¨Ïö© Ïãú None)
        """
        self.api_url = api_url or (
            "https://aws.amazon.com/api/dirs/items/search?"
            "item.directoryId=aws-products&"
            "sort_by=item.additionalFields.productNameLowercase&size=1000&"
            "language=en&item.locale=en_US"
        )
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        })
    
    def collect_products(self, timeout: int = 30) -> List[ProductInfo]:
        """
        AWS Ï†úÌíà Ï†ïÎ≥¥ ÏàòÏßë
        
        Args:
            timeout: API ÏöîÏ≤≠ ÌÉÄÏûÑÏïÑÏõÉ (Ï¥à)
            
        Returns:
            List[ProductInfo]: Ï†úÌíà Ï†ïÎ≥¥ Î¶¨Ïä§Ìä∏
            
        Raises:
            requests.RequestException: API ÏöîÏ≤≠ Ïã§Ìå® Ïãú
        """
        print(f"üîç AWS Ï†úÌíà Ï†ïÎ≥¥ ÏàòÏßë Ï§ë... (API: {self.api_url})")
        
        try:
            response = self.session.get(self.api_url, timeout=timeout)
            response.raise_for_status()
            data = response.json()
        except requests.RequestException as e:
            print(f"‚ùå API ÏöîÏ≤≠ Ïã§Ìå®: {e}")
            raise
        
        products = []
        items = data.get("items", [])
        
        print(f"üìä Î∞úÍ≤¨Îêú Ï†úÌíà: {len(items)}Í∞ú")
        
        for item in items:
            try:
                product_info = self._parse_product_item(item)
                if product_info:
                    products.append(product_info)
            except Exception as e:
                print(f"‚ö†Ô∏è Ï†úÌíà ÌååÏã± Ïã§Ìå®: {e}")
                continue
        
        print(f"‚úÖ ÏÑ±Í≥µÏ†ÅÏúºÎ°ú ÌååÏã±Îêú Ï†úÌíà: {len(products)}Í∞ú")
        return products
    
    def _parse_product_item(self, item: Dict) -> Optional[ProductInfo]:
        """
        Ï†úÌíà ÏïÑÏù¥ÌÖú ÌååÏã±
        
        Args:
            item: API ÏùëÎãµÏùò Ï†úÌíà ÏïÑÏù¥ÌÖú
            
        Returns:
            Optional[ProductInfo]: ÌååÏã±Îêú Ï†úÌíà Ï†ïÎ≥¥
        """
        try:
            item_data = item.get("item", {})
            additional_fields = item_data.get("additionalFields", {})
            
            # ÌïÑÏàò ÌïÑÎìú Ï∂îÏ∂ú
            product_name = additional_fields.get("productName", "")
            product_category = additional_fields.get("productCategory", "")
            product_url = additional_fields.get("productUrl", "")
            
            # URLÏóêÏÑú ÏÑúÎπÑÏä§Î™Ö Ï∂îÏ∂ú
            service_name = self._extract_service_from_url(product_url)
            
            # Í∑∏Î£πÎ™Ö Ï†ïÍ∑úÌôî
            group = self._normalize_group(product_category)
            
            # ÏÑ§Î™Ö Ï∂îÏ∂ú
            description = additional_fields.get("productDescription", "")
            
            if not product_name or not service_name:
                return None
            
            return ProductInfo(
                group=group,
                service=service_name,
                service_url=product_url,
                product_name=product_name,
                product_category=product_category,
                description=description
            )
            
        except Exception as e:
            print(f"‚ö†Ô∏è Ï†úÌíà ÏïÑÏù¥ÌÖú ÌååÏã± Ïã§Ìå®: {e}")
            return None
    
    def _extract_service_from_url(self, url: str) -> str:
        """
        URLÏóêÏÑú ÏÑúÎπÑÏä§Î™Ö Ï∂îÏ∂ú
        
        Args:
            url: Ï†úÌíà URL
            
        Returns:
            str: Ï∂îÏ∂úÎêú ÏÑúÎπÑÏä§Î™Ö
        """
        if not url:
            return ""
        
        # URLÏóêÏÑú ÏÑúÎπÑÏä§Î™Ö Ï∂îÏ∂ú
        # Ïòà: https://aws.amazon.com/ec2/ -> EC2
        # Ïòà: https://aws.amazon.com/s3/ -> S3
        
        # ÎßàÏßÄÎßâ Í≤ΩÎ°úÏóêÏÑú ÏÑúÎπÑÏä§Î™Ö Ï∂îÏ∂ú
        path = url.rstrip('/').split('/')[-1]
        
        # ÏùºÎ∞òÏ†ÅÏù∏ ÏÑúÎπÑÏä§Î™Ö Îß§Ìïë
        service_mapping = {
            'ec2': 'Amazon EC2',
            's3': 'Amazon S3',
            'rds': 'Amazon RDS',
            'lambda': 'AWS Lambda',
            'dynamodb': 'Amazon DynamoDB',
            'cloudfront': 'Amazon CloudFront',
            'vpc': 'Amazon VPC',
            'iam': 'AWS IAM',
            'sns': 'Amazon SNS',
            'sqs': 'Amazon SQS',
            'cloudwatch': 'Amazon CloudWatch',
            'ecs': 'Amazon ECS',
            'eks': 'Amazon EKS',
            'elb': 'Elastic Load Balancing',
            'autoscaling': 'Auto Scaling',
            'route53': 'Amazon Route 53',
            'cloudformation': 'AWS CloudFormation',
            'codecommit': 'AWS CodeCommit',
            'codebuild': 'AWS CodeBuild',
            'codedeploy': 'AWS CodeDeploy',
            'codepipeline': 'AWS CodePipeline',
            'elasticache': 'Amazon ElastiCache',
            'redshift': 'Amazon Redshift',
            'emr': 'Amazon EMR',
            'glue': 'AWS Glue',
            'athena': 'Amazon Athena',
            'quicksight': 'Amazon QuickSight',
            'sagemaker': 'Amazon SageMaker',
            'rekognition': 'Amazon Rekognition',
            'comprehend': 'Amazon Comprehend',
            'translate': 'Amazon Translate',
            'polly': 'Amazon Polly',
            'lex': 'Amazon Lex',
            'connect': 'Amazon Connect',
            'chime': 'Amazon Chime',
            'workspaces': 'Amazon WorkSpaces',
            'appstream': 'Amazon AppStream',
            'lightsail': 'Amazon Lightsail',
            'elasticbeanstalk': 'AWS Elastic Beanstalk',
            'opsworks': 'AWS OpsWorks',
            'config': 'AWS Config',
            'cloudtrail': 'AWS CloudTrail',
            'guardduty': 'Amazon GuardDuty',
            'macie': 'Amazon Macie',
            'shield': 'AWS Shield',
            'waf': 'AWS WAF',
            'kms': 'AWS Key Management Service',
            'secretsmanager': 'AWS Secrets Manager',
            'certificatemanager': 'AWS Certificate Manager',
            'directoryservice': 'AWS Directory Service',
            'cognito': 'Amazon Cognito',
            'organizations': 'AWS Organizations',
            'budgets': 'AWS Budgets',
            'costexplorer': 'AWS Cost Explorer',
            'billing': 'AWS Billing',
            'support': 'AWS Support',
            'marketplace': 'AWS Marketplace',
            'ram': 'AWS Resource Access Manager',
            'servicecatalog': 'AWS Service Catalog',
            'systemsmanager': 'AWS Systems Manager',
            'cloud9': 'AWS Cloud9',
            'xray': 'AWS X-Ray',
            'stepfunctions': 'AWS Step Functions',
            'apigateway': 'Amazon API Gateway',
            'appsync': 'AWS AppSync',
            'eventbridge': 'Amazon EventBridge',
            'mq': 'Amazon MQ',
            'kinesis': 'Amazon Kinesis',
            'msk': 'Amazon MSK',
            'elasticsearch': 'Amazon Elasticsearch Service',
            'opensearch': 'Amazon OpenSearch Service',
            'neptune': 'Amazon Neptune',
            'documentdb': 'Amazon DocumentDB',
            'timestream': 'Amazon Timestream',
            'keyspaces': 'Amazon Keyspaces',
            'qldb': 'Amazon QLDB',
            'managedblockchain': 'Amazon Managed Blockchain',
            'iot': 'AWS IoT',
            'greengrass': 'AWS IoT Greengrass',
            'iotanalytics': 'AWS IoT Analytics',
            'iotsitewise': 'AWS IoT SiteWise',
            'iotthingsgraph': 'AWS IoT Things Graph',
            'freertos': 'Amazon FreeRTOS',
            'robomaker': 'AWS RoboMaker',
            'groundstation': 'AWS Ground Station',
            'batch': 'AWS Batch',
            'parallelcluster': 'AWS ParallelCluster',
            'thinkbox': 'AWS Thinkbox',
            'nimblestudio': 'Amazon Nimble Studio',
            'elemental': 'AWS Elemental',
            'ivs': 'Amazon Interactive Video Service',
            'medialive': 'AWS MediaLive',
            'mediapackage': 'AWS MediaPackage',
            'mediastore': 'AWS MediaStore',
            'mediaconvert': 'AWS MediaConvert',
            'elementalmediaconnect': 'AWS Elemental MediaConnect',
            'elementalmedialive': 'AWS Elemental MediaLive',
            'elementalmediapackage': 'AWS Elemental MediaPackage',
            'elementalmediastore': 'AWS Elemental MediaStore',
            'elementalmediaconvert': 'AWS Elemental MediaConvert',
            'elementalmediatailor': 'AWS Elemental MediaTailor',
            'elementalmediaconnect': 'AWS Elemental MediaConnect',
            'elementalmedialive': 'AWS Elemental MediaLive',
            'elementalmediapackage': 'AWS Elemental MediaPackage',
            'elementalmediastore': 'AWS Elemental MediaStore',
            'elementalmediaconvert': 'AWS Elemental MediaConvert',
            'elementalmediatailor': 'AWS Elemental MediaTailor',
        }
        
        # Îß§ÌïëÏóêÏÑú Ï∞æÍ∏∞
        if path.lower() in service_mapping:
            return service_mapping[path.lower()]
        
        # Îß§ÌïëÏóê ÏóÜÏúºÎ©¥ URLÏóêÏÑú Ï∂îÏ∂ú
        if path:
            # Ï≤´ Í∏ÄÏûê ÎåÄÎ¨∏ÏûêÎ°ú Î≥ÄÌôò
            return path.upper()
        
        return ""
    
    def _normalize_group(self, category: str) -> str:
        """
        Ïπ¥ÌÖåÍ≥†Î¶¨Î•º Í∑∏Î£πÎ™ÖÏúºÎ°ú Ï†ïÍ∑úÌôî
        
        Args:
            category: ÏõêÎ≥∏ Ïπ¥ÌÖåÍ≥†Î¶¨Î™Ö
            
        Returns:
            str: Ï†ïÍ∑úÌôîÎêú Í∑∏Î£πÎ™Ö
        """
        if not category:
            return "Other"
        
        # Ïπ¥ÌÖåÍ≥†Î¶¨ Îß§Ìïë
        category_mapping = {
            "Compute": "Compute",
            "Storage": "Storage",
            "Database": "Database",
            "Networking & Content Delivery": "Networking & Content Delivery",
            "Security, Identity, & Compliance": "Security, Identity, & Compliance",
            "Management & Governance": "Management & Governance",
            "Application Integration": "Application Integration",
            "Analytics": "Analytics",
            "Artificial Intelligence": "Artificial Intelligence",
            "Machine Learning": "Machine Learning",
            "Media Services": "Media Services",
            "Developer Tools": "Developer Tools",
            "Front-End Web & Mobile": "Front-End Web & Mobile",
            "End User Computing": "End User Computing",
            "Internet of Things": "Internet of Things",
            "Migration & Modernization": "Migration & Modernization",
            "Quantum Technologies": "Quantum Technologies",
            "Robotics": "Robotics",
            "Satellite": "Satellite",
            "Blockchain": "Blockchain",
            "Business Applications": "Business Applications",
            "Cloud Financial Management": "Cloud Financial Management",
            "Customer Enablement": "Customer Enablement",
            "Games": "Games",
            "General": "General",
        }
        
        return category_mapping.get(category, category)
    
    def save_products(self, products: List[ProductInfo], 
                     csv_path: str, json_path: str) -> None:
        """
        Ï†úÌíà Ï†ïÎ≥¥Î•º CSVÏôÄ JSON ÌååÏùºÎ°ú Ï†ÄÏû•
        
        Args:
            products: Ï†úÌíà Ï†ïÎ≥¥ Î¶¨Ïä§Ìä∏
            csv_path: CSV Ï∂úÎ†• ÌååÏùº Í≤ΩÎ°ú
            json_path: JSON Ï∂úÎ†• ÌååÏùº Í≤ΩÎ°ú
        """
        # Ï∂úÎ†• ÎîîÎ†âÌÑ∞Î¶¨ ÏÉùÏÑ±
        Path(csv_path).parent.mkdir(parents=True, exist_ok=True)
        Path(json_path).parent.mkdir(parents=True, exist_ok=True)
        
        # CSV Ï†ÄÏû•
        with open(csv_path, "w", newline="", encoding="utf-8") as f:
            w = csv.writer(f)
            w.writerow(["group", "service", "service_url", "product_name", "product_category", "description"])
            for product in products:
                w.writerow([
                    product.group,
                    product.service,
                    product.service_url,
                    product.product_name,
                    product.product_category,
                    product.description
                ])
        
        # JSON Ï†ÄÏû•
        json_data = []
        for product in products:
            json_data.append({
                "group": product.group,
                "service": product.service,
                "service_url": product.service_url,
                "product_name": product.product_name,
                "product_category": product.product_category,
                "description": product.description
            })
        
        with open(json_path, "w", encoding="utf-8") as f:
            json.dump(json_data, f, ensure_ascii=False, indent=2)
        
        print(f"‚úÖ CSV: {csv_path}  rows={len(products)}")
        print(f"‚úÖ JSON: {json_path}  rows={len(products)}")
    
    def get_statistics(self, products: List[ProductInfo]) -> Dict:
        """Ï†úÌíà Ï†ïÎ≥¥ ÌÜµÍ≥Ñ"""
        stats = {
            "total_products": len(products),
            "groups": {},
            "services": {}
        }
        
        for product in products:
            # Í∑∏Î£πÎ≥Ñ ÌÜµÍ≥Ñ
            stats["groups"][product.group] = stats["groups"].get(product.group, 0) + 1
            
            # ÏÑúÎπÑÏä§Î≥Ñ ÌÜµÍ≥Ñ
            stats["services"][product.service] = stats["services"].get(product.service, 0) + 1
        
        return stats
